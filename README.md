# CURSO DE RUBY
üë®‚Äç‚öñÔ∏èRUBY √â UMA LINGUAGEM DE PROGRAMA√á√ÉO.

[![GitHub Repo stars](https://img.shields.io/badge/VILHALVA-GITHUB-03A9F4?logo=github)](https://github.com/VILHALVA) 
[![GitHub Repo stars](https://img.shields.io/badge/VEJA%20OS-VIDEOS-03A9F4?logo=youtube)](https://www.youtube.com/@vilhalva100/search?query=Ruby)

[![GitHub Repo stars](https://img.shields.io/badge/VEJA-DOCUMENTA√á√ÉO-03A9F4?logo=google)](https://www.ruby-lang.org/en/documentation/) <br>

[![GitHub Repo stars](https://img.shields.io/badge/-PLAYLIST%20DO%20YOUTUBE-blueviolet)](https://www.youtube.com/playlist?list=PLdDT8if5attEOcQGPHLNIfnSFiJHhGDOZ)

<img src="https://cdn.icon-icons.com/icons2/2415/PNG/512/ruby_plain_wordmark_logo_icon_146362.png" align="center" width="280"> <br>

![](https://i.imgur.com/waxVImv.png)

# üëÄVIS√ÉO PANOR√ÇMICA:
| PERGUNTA | RESPOSTA |
| :---: | :---: |
| DATA DE CRIA√á√ÉO | 1993 |
| NOME DO CRIADOR | Yukihiro Matsumoto | 
| SIGNIFICADO DO NOME | O nome "Ruby" foi escolhido por Matz como uma refer√™ncia √† sua simplicidade e beleza. |
| √â BASEADA NO | Perl, Smalltalk, Eiffel e Lisp |
| EXTEN√á√ÉO DO ARQUIVO | .rb |
| √â MAIS USADA | Desenvolvimento web e Desenvolvimento de Jogos |

- **Data de Cria√ß√£o:** Ruby foi criada em 24 de fevereiro de 1993, quando seu criador, Yukihiro Matsumoto (tamb√©m conhecido como Matz), lan√ßou a primeira vers√£o p√∫blica, Ruby 0.95.

- **Nome do Criador:** A linguagem Ruby foi criada por Yukihiro Matsumoto, que √© um programador japon√™s conhecido como Matz.

- **Significado do Nome:** O nome "Ruby" foi escolhido por Matz como uma refer√™ncia √† sua simplicidade e beleza. Ele queria uma linguagem de programa√ß√£o que fosse mais orientada para o prazer do programador, e o nome Ruby reflete essa ideia, pois √© uma pedra preciosa muito apreciada.

- **Baseada em:** Ruby √© uma linguagem de programa√ß√£o que foi influenciada por v√°rias outras linguagens, como Perl, Smalltalk, Eiffel e Lisp. No entanto, ela n√£o √© baseada diretamente em nenhuma linguagem espec√≠fica.

- **Extens√£o do Arquivo:** Os arquivos de c√≥digo-fonte Ruby t√™m a extens√£o ".rb". Por exemplo, um programa em Ruby pode ser salvo como "meu_programa.rb".

- **Uso Principal:** Ruby √© conhecida por sua simplicidade e flexibilidade, tornando-a adequada para uma variedade de aplica√ß√µes. Ela √© frequentemente usada para desenvolvimento web, especialmente com o framework Ruby on Rails, que √© amplamente utilizado para criar aplicativos web. Al√©m disso, Ruby √© usada em automa√ß√£o de tarefas, desenvolvimento de jogos, an√°lise de dados e uma variedade de outros dom√≠nios de programa√ß√£o.

# ü§≥SINTAXE DA LINGUAGEM:
## 0) FUNDAMENTOS:
Aqui est√° um exemplo simples de c√≥digo Ruby que utiliza operadores aritm√©ticos, relacionais e l√≥gicos com tipos primitivos:

```ruby
# Vari√°veis com valores
a = 5
b = 3

# Operadores aritm√©ticos
soma = a + b
subtracao = a - b
multiplicacao = a * b
divisao = a / b
resto = a % b

puts "Operadores Aritm√©ticos:"
puts "Soma: #{soma}"
puts "Subtra√ß√£o: #{subtracao}"
puts "Multiplica√ß√£o: #{multiplicacao}"
puts "Divis√£o: #{divisao}"
puts "Resto da divis√£o: #{resto}"

# Operadores relacionais
igual = a == b
diferente = a != b
maior = a > b
menor = a < b
maior_ou_igual = a >= b
menor_ou_igual = a <= b

puts "\nOperadores Relacionais:"
puts "Igual: #{igual}"
puts "Diferente: #{diferente}"
puts "Maior: #{maior}"
puts "Menor: #{menor}"
puts "Maior ou Igual: #{maior_ou_igual}"
puts "Menor ou Igual: #{menor_ou_igual}"

# Operadores l√≥gicos
verdadeiro = true
falso = false

# AND l√≥gico
resultado_and = verdadeiro && falso

# OR l√≥gico
resultado_or = verdadeiro || falso

# NOT l√≥gico
resultado_not = !verdadeiro

puts "\nOperadores L√≥gicos:"
puts "AND L√≥gico: #{resultado_and}"
puts "OR L√≥gico: #{resultado_or}"
puts "NOT L√≥gico: #{resultado_not}"
```

Neste c√≥digo, definimos duas vari√°veis `a` e `b` com valores num√©ricos e demonstramos o uso de operadores aritm√©ticos (adi√ß√£o, subtra√ß√£o, multiplica√ß√£o, divis√£o e resto), operadores relacionais (igualdade, desigualdade, maior, menor, maior ou igual, menor ou igual) e operadores l√≥gicos (AND, OR e NOT) com vari√°veis booleanas `verdadeiro` e `falso`. Os resultados de cada opera√ß√£o s√£o exibidos no console com a fun√ß√£o `puts`.

## 1) VARIAVEIS SIMPLES:
Vari√°veis s√£o elementos fundamentais na programa√ß√£o e s√£o usadas para armazenar dados que podem ser manipulados e processados por um programa. Em Ruby, voc√™ pode criar vari√°veis simples para armazenar diferentes tipos de dados. Aqui est√£o alguns exemplos de vari√°veis simples em Ruby:

1. **Vari√°veis de N√∫meros Inteiros:**

```ruby
idade = 25
```

Neste exemplo, a vari√°vel `idade` armazena um valor inteiro de 25.

2. **Vari√°veis de N√∫meros de Ponto Flutuante:**

```ruby
altura = 1.75
```

Aqui, a vari√°vel `altura` armazena um valor de ponto flutuante representando a altura de uma pessoa.

3. **Vari√°veis de Texto (Strings):**

```ruby
nome = "Jo√£o"
```

A vari√°vel `nome` armazena uma sequ√™ncia de caracteres (string) representando o nome "Jo√£o".

4. **Vari√°veis Booleanas:**

```ruby
ativo = true
```

A vari√°vel `ativo` armazena um valor booleano `true`, indicando que algo est√° ativo.

5. **Vari√°veis Nulas (nil):**

```ruby
endereco = nil
```

A vari√°vel `endereco` √© inicializada com `nil`, que representa a aus√™ncia de valor. Ela ainda n√£o possui um valor atribu√≠do.

6. **Vari√°veis Constantes:**

```ruby
PI = 3.14159
```

Em Ruby, as constantes s√£o escritas com letras mai√∫sculas. Neste caso, `PI` √© uma constante que armazena o valor de pi.

7. **Vari√°veis de Arrays:**

```ruby
cores = ["vermelho", "verde", "azul"]
```

A vari√°vel `cores` armazena um array de strings contendo v√°rias cores.

8. **Vari√°veis de Hashes:**

```ruby
pessoa = { "nome" => "Maria", "idade" => 30 }
```

A vari√°vel `pessoa` armazena um hash que mapeia chaves ("nome" e "idade") para valores ("Maria" e 30).

Em Ruby, as vari√°veis s√£o dinamicamente tipadas, o que significa que voc√™ n√£o precisa especificar o tipo de dados ao declar√°-las. O tipo √© determinado automaticamente com base no valor que voc√™ atribui a elas. Isso torna a linguagem mais flex√≠vel e f√°cil de usar.

Lembre-se de que, ao nomear vari√°veis em Ruby, √© uma pr√°tica comum usar letras min√∫sculas e separar palavras com underscores (snake_case) para tornar o c√≥digo mais leg√≠vel. Por exemplo, `nome_completo` em vez de `NomeCompleto`.

Aqui est√° um exemplo de como usar a entrada de dados (input) em Ruby com uma breve explica√ß√£o:

```ruby
# Solicita ao usu√°rio que insira seu nome
print "Por favor, digite seu nome: "

# Obt√©m a entrada do usu√°rio e a armazena na vari√°vel "nome"
nome = gets.chomp

# Exibe uma sauda√ß√£o com o nome inserido pelo usu√°rio
puts "Ol√°, #{nome}! Bem-vindo ao nosso programa."
```

Neste exemplo, estamos fazendo uso da entrada de dados para obter o nome do usu√°rio e, em seguida, exibimos uma sauda√ß√£o personalizada usando esse nome. Vamos explicar cada parte do c√≥digo:

1. `print "Por favor, digite seu nome: "`: Isso imprime uma mensagem no console, solicitando ao usu√°rio que insira seu nome. O `print` √© usado para exibir a mensagem sem uma quebra de linha, para que o cursor fique na mesma linha de entrada.

2. `nome = gets.chomp`: A fun√ß√£o `gets` √© usada para obter a entrada do usu√°rio a partir do teclado. O m√©todo `chomp` √© chamado para remover a quebra de linha (newline) que √© automaticamente adicionada ao final da entrada pelo `gets`. O nome inserido pelo usu√°rio √© armazenado na vari√°vel `nome`.

3. `puts "Ol√°, #{nome}! Bem-vindo ao nosso programa."`: Aqui, usamos a fun√ß√£o `puts` para exibir uma sauda√ß√£o personalizada, incluindo o nome inserido pelo usu√°rio. A interpola√ß√£o de strings √© usada para incorporar o valor da vari√°vel `nome` na mensagem.

Quando voc√™ executa este programa, ele ir√°:

1. Solicitar ao usu√°rio que insira seu nome.
2. Aguardar a entrada do usu√°rio.
3. Armazenar a entrada do usu√°rio na vari√°vel `nome`.
4. Exibir uma sauda√ß√£o personalizada com o nome do usu√°rio.

Isso demonstra como usar entrada de dados em Ruby para interagir com o usu√°rio e capturar informa√ß√µes que podem ser usadas em seu programa.

## 2) ESTRUTURA CONDICIONAL:
### ESTRUTURA IF-ELSE:
A estrutura `if-else` em Ruby √© usada para tomar decis√µes com base em uma condi√ß√£o. Ela permite que voc√™ execute um bloco de c√≥digo se a condi√ß√£o especificada for verdadeira e outro bloco de c√≥digo se a condi√ß√£o for falsa. Aqui est√° a sintaxe b√°sica da estrutura `if-else` em Ruby:

```ruby
if condi√ß√£o
  # Bloco de c√≥digo a ser executado se a condi√ß√£o for verdadeira
else
  # Bloco de c√≥digo a ser executado se a condi√ß√£o for falsa
end
```

Aqui est√£o alguns exemplos de como usar a estrutura `if-else` em Ruby:

**Exemplo 1: Verificando se um n√∫mero √© positivo ou negativo:**

```ruby
# Solicita ao usu√°rio que insira um n√∫mero
print "Por favor, insira um n√∫mero: "
numero = gets.to_i

if numero > 0
  puts "O n√∫mero √© positivo."
elsif numero < 0
  puts "O n√∫mero √© negativo."
else
  puts "O n√∫mero √© zero."
end
```

Neste exemplo, a condi√ß√£o `if` verifica se o n√∫mero √© maior que zero, a condi√ß√£o `elsif` verifica se o n√∫mero √© menor que zero, e o bloco `else` √© executado se nenhuma das condi√ß√µes anteriores for verdadeira.

**Exemplo 2: Verificando se um usu√°rio tem idade suficiente para acessar um site:**

```ruby
# Solicita ao usu√°rio que insira sua idade
print "Por favor, insira sua idade: "
idade = gets.to_i

if idade >= 18
  puts "Voc√™ tem idade suficiente para acessar o site."
else
  puts "Desculpe, voc√™ n√£o tem idade suficiente para acessar o site."
end
```

Neste caso, a condi√ß√£o `if` verifica se a idade √© maior ou igual a 18, permitindo ou negando o acesso com base nessa condi√ß√£o.

A estrutura `if-else` √© uma das estruturas de controle de fluxo fundamentais em Ruby e √© amplamente usada para tomar decis√µes em programas. Ela permite que voc√™ crie l√≥gica condicional para que seu programa execute diferentes a√ß√µes com base nas condi√ß√µes especificadas.

### ESTRUTURA IF-ELSE, ELSE IF:
A estrutura `if-else if-else`, tamb√©m conhecida como estrutura condicional m√∫ltipla, permite lidar com v√°rias condi√ß√µes em sequ√™ncia. Ela √© usada quando voc√™ tem mais de duas possibilidades e deseja executar diferentes blocos de c√≥digo com base em v√°rias condi√ß√µes. Aqui est√° a sintaxe da estrutura `if-else if-else` em Ruby:

```ruby
if condi√ß√£o_1
  # Bloco de c√≥digo a ser executado se a condi√ß√£o_1 for verdadeira
elsif condi√ß√£o_2
  # Bloco de c√≥digo a ser executado se a condi√ß√£o_2 for verdadeira
elsif condi√ß√£o_3
  # Bloco de c√≥digo a ser executado se a condi√ß√£o_3 for verdadeira
else
  # Bloco de c√≥digo a ser executado se nenhuma das condi√ß√µes anteriores for verdadeira
end
```

Aqui est√£o alguns exemplos de como usar a estrutura `if-else if-else` em Ruby:

**Exemplo 1: Determinando a faixa et√°ria com base na idade:**

```ruby
# Solicita ao usu√°rio que insira sua idade
print "Por favor, insira sua idade: "
idade = gets.to_i

if idade < 18
  puts "Voc√™ √© menor de idade."
elsif idade >= 18 && idade < 65
  puts "Voc√™ √© um adulto."
else
  puts "Voc√™ √© um idoso."
end
```

Neste exemplo, utilizamos `if` para verificar se a idade √© menor que 18, `elsif` para verificar se a idade est√° na faixa de 18 a 64 e `else` para lidar com todas as outras idades, considerando-as como idosos.

**Exemplo 2: Classificando um n√∫mero em rela√ß√£o a zero:**

```ruby
# Solicita ao usu√°rio que insira um n√∫mero
print "Por favor, insira um n√∫mero: "
numero = gets.to_i

if numero > 0
  puts "O n√∫mero √© positivo."
elsif numero < 0
  puts "O n√∫mero √© negativo."
else
  puts "O n√∫mero √© zero."
end
```

Neste caso, estamos usando `if` para verificar se o n√∫mero √© maior que zero, `elsif` para verificar se o n√∫mero √© menor que zero e `else` para tratar o caso em que o n√∫mero √© igual a zero.

A estrutura `if-else if-else` √© √∫til quando voc√™ precisa lidar com v√°rias condi√ß√µes em sequ√™ncia e deseja executar diferentes a√ß√µes com base nessas condi√ß√µes. Cada `elsif` √© avaliado somente se as condi√ß√µes anteriores forem falsas, e o bloco `else` √© executado se nenhuma das condi√ß√µes anteriores for verdadeira.

### ESTRUTURA SWITCH:
Ruby n√£o possui uma estrutura `switch` como algumas outras linguagens de programa√ß√£o, como C++ ou Java. Em vez disso, Ruby utiliza a estrutura `case` e `when` para realizar opera√ß√µes condicionais semelhantes. 

Aqui est√° um exemplo de como usar a estrutura `case` e `when` em Ruby:

```ruby
# Solicita ao usu√°rio que insira um n√∫mero de 1 a 5
print "Por favor, insira um n√∫mero de 1 a 5: "
numero = gets.to_i

# Utiliza a estrutura case para realizar diferentes a√ß√µes com base no n√∫mero
case numero
when 1
  puts "Voc√™ escolheu o n√∫mero um."
when 2
  puts "Voc√™ escolheu o n√∫mero dois."
when 3
  puts "Voc√™ escolheu o n√∫mero tr√™s."
when 4
  puts "Voc√™ escolheu o n√∫mero quatro."
when 5
  puts "Voc√™ escolheu o n√∫mero cinco."
else
  puts "N√∫mero fora do intervalo especificado."
end
```

Neste exemplo, utilizamos `case` para comparar a vari√°vel `numero` com uma s√©rie de valores poss√≠veis. Se `numero` coincidir com um dos valores especificados ap√≥s `when`, o c√≥digo dentro desse `when` ser√° executado. Se nenhum dos valores coincidir, o bloco `else` ser√° executado.

A estrutura `case` e `when` em Ruby √© uma alternativa flex√≠vel e leg√≠vel ao `switch` de outras linguagens, permitindo que voc√™ execute diferentes blocos de c√≥digo com base em uma vari√°vel ou express√£o. √â uma maneira eficaz de lidar com v√°rias op√ß√µes condicionais.

## 3) ESTRUTURA DE REPETI√á√ÉO:
### ESTRUTURA FOR:
Em Ruby, a estrutura `for` √© usada para criar loops que iteram por uma cole√ß√£o de elementos, como um array ou um intervalo. No entanto, a prefer√™ncia na linguagem Ruby √© usar a itera√ß√£o com m√©todos como `each`, `times`, `upto`, `downto` e outros, em vez de usar a estrutura `for`. Vou mostrar um exemplo do uso da estrutura `for`, mas tamb√©m recomendaria que voc√™ explore as alternativas mais idiom√°ticas em Ruby para loops.

Aqui est√° um exemplo b√°sico de como usar a estrutura `for` para percorrer um array de n√∫meros:

```ruby
# Criando um array de n√∫meros
numeros = [1, 2, 3, 4, 5]

# Usando a estrutura for para iterar pelos elementos do array
for numero in numeros
  puts numero
end
```

Neste exemplo, o `for numero in numeros` cria um loop que itera por cada elemento do array `numeros`, e o valor atual √© armazenado na vari√°vel `numero`. O loop imprime cada n√∫mero no console.

No entanto, a abordagem mais comum em Ruby para iterar por elementos em um array √© usar o m√©todo `each`:

```ruby
numeros.each do |numero|
  puts numero
end
```

Al√©m disso, se voc√™ quiser criar um loop que execute um n√∫mero espec√≠fico de vezes, √© mais comum usar o m√©todo `times`:

```ruby
5.times do |i|
  puts "Esta √© a itera√ß√£o n√∫mero #{i + 1}"
end
```

A abordagem `times` √© mais leg√≠vel e idiom√°tica em Ruby para a maioria dos casos de loops com um n√∫mero fixo de itera√ß√µes. Portanto, enquanto a estrutura `for` √© v√°lida em Ruby, muitos programadores Ruby preferem m√©todos de itera√ß√£o mais expressivos e espec√≠ficos da linguagem.

### ESTRUTURA WHILE:
A estrutura `while` em Ruby √© usada para criar um loop que executa um bloco de c√≥digo repetidamente enquanto uma condi√ß√£o especificada for verdadeira. Aqui est√° a sintaxe b√°sica da estrutura `while`:

```ruby
while condi√ß√£o
  # Bloco de c√≥digo a ser executado enquanto a condi√ß√£o for verdadeira
end
```

O bloco de c√≥digo dentro do `while` ser√° executado repetidamente enquanto a `condi√ß√£o` fornecida for avaliada como verdadeira. Se a condi√ß√£o for inicialmente falsa, o bloco n√£o ser√° executado.

Aqui est√° um exemplo simples de como usar a estrutura `while` para contar de 1 a 5:

```ruby
# Inicializa uma vari√°vel de controle
contador = 1

# Cria um loop while que executa enquanto o contador for menor ou igual a 5
while contador <= 5
  puts contador
  contador += 1 # Incrementa o contador
end
```

Neste exemplo, o c√≥digo dentro do `while` ser√° executado repetidamente enquanto o valor da vari√°vel `contador` for menor ou igual a 5. O contador √© incrementado a cada itera√ß√£o para evitar um loop infinito.

Lembre-se de que √© importante tomar cuidado ao usar a estrutura `while`, pois, se a condi√ß√£o n√£o for alterada dentro do loop, voc√™ pode criar um loop infinito que continuar√° executando indefinidamente.

Outra estrutura relacionada √© o `do-while` em Ruby, que √© chamado de `begin..end while` e garante que o bloco de c√≥digo seja executado pelo menos uma vez, mesmo que a condi√ß√£o seja inicialmente falsa:

```ruby
# Exemplo de do-while em Ruby
begin
  puts "Este bloco ser√° executado pelo menos uma vez."
end while false
```

Embora o uso do `while` seja v√°lido e √∫til em muitos casos, em Ruby, a prefer√™ncia √© dada √†s itera√ß√µes com m√©todos mais expressivos e espec√≠ficos da linguagem, como `each`, `times`, `upto`, `downto` e outros, que costumam ser mais idiom√°ticos.

### ESTRUTURA DO-WHILE:
Em Ruby, n√£o existe uma estrutura de controle `do-while` como em algumas outras linguagens de programa√ß√£o, como C/C++ ou Java. No entanto, voc√™ pode criar um loop semelhante que garanta que o bloco de c√≥digo seja executado pelo menos uma vez, mesmo que a condi√ß√£o seja falsa inicialmente, usando uma abordagem diferente. A t√©cnica comum √© usar `begin..end` em conjunto com `while` ou `until`. 

Aqui est√° um exemplo de como criar uma estrutura semelhante a `do-while` em Ruby:

```ruby
begin
  # Bloco de c√≥digo a ser executado pelo menos uma vez
  puts "Este bloco ser√° executado pelo menos uma vez."
end while false
```

Neste exemplo, o bloco de c√≥digo dentro de `begin..end` ser√° executado uma vez antes de verificar a condi√ß√£o `while`. Se a condi√ß√£o for falsa, o bloco ser√° executado pelo menos uma vez e pode continuar a ser executado enquanto a condi√ß√£o for verdadeira.

Voc√™ tamb√©m pode usar a estrutura `until` para criar uma l√≥gica semelhante:

```ruby
begin
  # Bloco de c√≥digo a ser executado pelo menos uma vez
  puts "Este bloco ser√° executado pelo menos uma vez."
end until true
```

Embora a estrutura `do-while` n√£o seja uma constru√ß√£o direta em Ruby, essa abordagem com `begin..end` em conjunto com `while` ou `until` atinge o mesmo resultado, garantindo que o c√≥digo dentro do bloco seja executado pelo menos uma vez antes de verificar a condi√ß√£o de sa√≠da.

## 4) VARIAVEIS COMPOSTAS:
### ARRAYS:
Em Ruby, um array √© uma cole√ß√£o ordenada de elementos, onde cada elemento pode ser de qualquer tipo, incluindo n√∫meros, strings, objetos, outros arrays e assim por diante. Os arrays em Ruby s√£o din√¢micos, o que significa que voc√™ pode adicionar ou remover elementos facilmente. Aqui est√£o alguns conceitos e exemplos relacionados a arrays em Ruby:

**1. Criando um Array:**
   Para criar um array em Ruby, voc√™ pode usar a nota√ß√£o de colchetes `[]` e inserir os elementos entre eles, separados por v√≠rgulas. Por exemplo:

   ```ruby
   numeros = [1, 2, 3, 4, 5]
   nomes = ["Alice", "Bob", "Charlie"]
   ```

**2. Acessando Elementos:**
   Voc√™ pode acessar os elementos de um array por meio de seus √≠ndices. O √≠ndice do primeiro elemento √© 0, o do segundo √© 1 e assim por diante. Por exemplo:

   ```ruby
   numeros = [1, 2, 3, 4, 5]
   primeiro_numero = numeros[0]  # primeiro_numero conter√° 1
   ```

**3. Modificando Elementos:**
   Voc√™ pode modificar os elementos de um array atribuindo um novo valor a um √≠ndice espec√≠fico. Por exemplo:

   ```ruby
   numeros = [1, 2, 3, 4, 5]
   numeros[2] = 10  # Agora o array se torna [1, 2, 10, 4, 5]
   ```

**4. Adicionando e Removendo Elementos:**
   Voc√™ pode adicionar elementos a um array usando o m√©todo `push` ou `<<` e remover elementos com o m√©todo `pop`. Por exemplo:

   ```ruby
   numeros = [1, 2, 3]
   numeros.push(4)  # Adiciona 4 ao final do array
   numeros << 5     # Adiciona 5 ao final do array
   numeros.pop      # Remove o √∫ltimo elemento, o array fica [1, 2, 3, 4]
   ```

**5. M√©todos √öteis:**
   Ruby oferece uma variedade de m√©todos √∫teis para trabalhar com arrays, como `each`, `map`, `select`, `reject`, `sort`, `reverse` e muitos outros. Esses m√©todos facilitam a manipula√ß√£o e a itera√ß√£o atrav√©s dos elementos de um array.

Aqui est√° um exemplo de itera√ß√£o por um array usando `each`:

```ruby
numeros = [1, 2, 3, 4, 5]

numeros.each do |numero|
  puts "O n√∫mero √© #{numero}"
end
```

Este √© apenas um breve resumo sobre arrays em Ruby. Eles s√£o amplamente utilizados na linguagem para armazenar e manipular cole√ß√µes de dados, e voc√™ pode explorar uma variedade de m√©todos e t√©cnicas para trabalhar com eles de maneira eficiente.

### LISTAS:
Em Ruby, n√£o existe uma estrutura de dados chamada "lista" no sentido estrito como em algumas outras linguagens de programa√ß√£o, como Python. No entanto, em Ruby, voc√™ pode usar arrays para criar estruturas de dados semelhantes a listas. Arrays em Ruby s√£o cole√ß√µes ordenadas de elementos que podem conter diversos tipos de dados. Eles s√£o usados para armazenar conjuntos de valores em uma √∫nica vari√°vel.

Aqui est√° um exemplo de como criar e usar uma estrutura de lista usando arrays em Ruby:

```ruby
# Criando uma "lista" usando um array
lista_de_compras = ["Ma√ß√£s", "Bananas", "Leite", "P√£o"]

# Adicionando um item √† lista
lista_de_compras << "Ovos"

# Acessando um item da lista
primeiro_item = lista_de_compras[0]  # "Ma√ß√£s"

# Modificando um item da lista
lista_de_compras[1] = "Laranjas"

# Removendo um item da lista
lista_de_compras.delete("Leite")

# Iterando pela lista
lista_de_compras.each do |item|
  puts "Item: #{item}"
end
```

Neste exemplo, `lista_de_compras` √© um array que cont√©m uma lista de itens. Voc√™ pode adicionar, acessar, modificar e remover itens da lista, bem como iterar por ela usando m√©todos e t√©cnicas dispon√≠veis em Ruby.

Embora Ruby n√£o tenha uma estrutura de dados espec√≠fica chamada "lista," os arrays em Ruby s√£o vers√°teis e funcionam bem para criar e gerenciar cole√ß√µes ordenadas de elementos, o que √© semelhante ao que voc√™ faria com uma lista em outras linguagens de programa√ß√£o.

### DICION√ÅRIOS:
Em Ruby, os dicion√°rios s√£o chamados de "hashes." Um hash √© uma estrutura de dados que permite associar pares chave-valor, onde cada chave √© √∫nica. Os hashes em Ruby s√£o altamente flex√≠veis e s√£o amplamente usados para mapear valores a chaves e recuperar rapidamente esses valores com base nas chaves. Aqui est√° uma introdu√ß√£o aos hashes em Ruby:

**Criando um Hash:**
Para criar um hash em Ruby, voc√™ pode usar a sintaxe `{}` e especificar pares chave-valor separados por v√≠rgulas. Por exemplo:

```ruby
pessoa = {
  "nome" => "Alice",
  "idade" => 30,
  "cidade" => "S√£o Paulo"
}
```

**Acessando Valores:**
Voc√™ pode acessar os valores de um hash usando as chaves correspondentes. Por exemplo:

```ruby
nome = pessoa["nome"]     # "Alice"
idade = pessoa["idade"]   # 30
cidade = pessoa["cidade"] # "S√£o Paulo"
```

**Modificando Valores:**
Voc√™ pode modificar os valores de um hash atribuindo um novo valor a uma chave existente ou adicionando novos pares chave-valor. Por exemplo:

```ruby
pessoa["idade"] = 31   # Modifica a idade para 31
pessoa["sexo"] = "F"   # Adiciona a chave "sexo" com o valor "F"
```

**Removendo Chaves e Valores:**
Voc√™ pode remover uma chave e seu valor correspondente de um hash usando o m√©todo `delete`. Por exemplo:

```ruby
pessoa.delete("idade") # Remove a chave "idade" e seu valor
```

**Iterando pelos Pares Chave-Valor:**
Voc√™ pode iterar pelos pares chave-valor de um hash usando o m√©todo `each`. Por exemplo:

```ruby
pessoa.each do |chave, valor|
  puts "#{chave}: #{valor}"
end
```

**Verificando se uma Chave Existe:**
Voc√™ pode verificar se uma chave espec√≠fica existe em um hash usando o m√©todo `has_key?` (ou seu alias `key?`) ou `include?`. Por exemplo:

```ruby
tem_nome = pessoa.has_key?("nome") # true
tem_altura = pessoa.key?("altura")  # false
```

Os hashes em Ruby s√£o extremamente √∫teis para mapear dados de forma eficiente, permitindo que voc√™ associe informa√ß√µes a chaves e, em seguida, recupere essas informa√ß√µes rapidamente usando as chaves. Eles s√£o uma estrutura de dados fundamental em Ruby e s√£o amplamente usados em programa√ß√£o.

## 5) FUN√á√ïES:
Em Ruby, fun√ß√µes s√£o chamadas de "m√©todos". M√©todos s√£o blocos de c√≥digo que realizam tarefas espec√≠ficas e podem ser chamados para executar essas tarefas sempre que necess√°rio. Os m√©todos s√£o uma parte fundamental da programa√ß√£o em Ruby e s√£o usados para organizar e reutilizar c√≥digo de forma eficiente. Vou explicar como definir e chamar m√©todos em Ruby:

**Definindo um M√©todo:**
Para definir um m√©todo em Ruby, voc√™ usa a palavra-chave `def`, seguida pelo nome do m√©todo e, opcionalmente, par√¢metros que o m√©todo pode receber. O m√©todo √© finalizado com a palavra-chave `end`. Aqui est√° um exemplo de defini√ß√£o de um m√©todo simples que cumprimenta algu√©m:

```ruby
def cumprimentar(nome)
  puts "Ol√°, #{nome}!"
end
```

Neste exemplo, o m√©todo `cumprimentar` recebe um par√¢metro `nome` e imprime uma sauda√ß√£o com o nome fornecido.

**Chamando um M√©todo:**
Para chamar um m√©todo em Ruby, voc√™ simplesmente digita o nome do m√©todo, seguido de par√™nteses que cont√™m quaisquer argumentos necess√°rios para o m√©todo. Por exemplo:

```ruby
cumprimentar("Alice") # Chama o m√©todo cumprimentar com o argumento "Alice"
```

**Retornando Valores de um M√©todo:**
Os m√©todos podem retornar valores usando a palavra-chave `return`. Por exemplo:

```ruby
def soma(a, b)
  return a + b
end

resultado = soma(3, 4) # Chama o m√©todo soma e armazena o resultado em resultado
puts resultado # Imprime o resultado, que √© 7
```

No entanto, em Ruby, √© comum omitir a palavra-chave `return`, e o valor da √∫ltima linha do m√©todo √© automaticamente retornado.

**M√©todos sem Argumentos:**
Voc√™ tamb√©m pode definir m√©todos que n√£o aceitam argumentos. Por exemplo:

```ruby
def saudacao
  puts "Ol√°, mundo!"
end

saudacao # Chama o m√©todo saudacao
```

**M√©todos com Argumentos Opcionais:**
Voc√™ pode definir m√©todos com argumentos opcionais, fornecendo um valor padr√£o para os par√¢metros. Por exemplo:

```ruby
def saudacao(nome="An√¥nimo")
  puts "Ol√°, #{nome}!"
end

saudacao("Alice") # Chama o m√©todo com o nome "Alice"
saudacao # Chama o m√©todo sem um nome, usando o valor padr√£o "An√¥nimo"
```

Esses s√£o os conceitos b√°sicos de como definir, chamar e retornar valores de m√©todos em Ruby. Os m√©todos s√£o uma parte fundamental da linguagem e permitem que voc√™ crie c√≥digo mais organizado e reutiliz√°vel em seus programas Ruby.

## 6) CLASS POO:
Vou fornecer exemplos de c√≥digo em Ruby para cada um dos quatro pilares da Programa√ß√£o Orientada a Objetos (POO) e explicar cada um deles.

**1. Encapsulamento:**
   - O encapsulamento envolve o ocultamento dos detalhes internos de um objeto e o fornecimento de uma interface p√∫blica para interagir com ele.

   ```ruby
   class ContaBancaria
     def initialize(saldo_inicial)
       @saldo = saldo_inicial
     end

     def depositar(valor)
       @saldo += valor
     end

     def sacar(valor)
       if valor <= @saldo
         @saldo -= valor
       else
         puts "Saldo insuficiente."
       end
     end

     def saldo
       @saldo
     end
   end

   conta = ContaBancaria.new(1000)
   conta.depositar(500)
   conta.sacar(200)
   puts "Saldo atual: #{conta.saldo}" # Acesso controlado ao saldo
   ```

   Neste exemplo, a classe `ContaBancaria` encapsula o saldo e fornece m√©todos p√∫blicos (`depositar`, `sacar`, `saldo`) para interagir com ele, mantendo o saldo oculto dos usu√°rios diretos.

**2. Abstra√ß√£o:**
   - Abstra√ß√£o envolve a simplifica√ß√£o de objetos complexos, destacando apenas os detalhes essenciais.

   ```ruby
   class Veiculo
     def acelerar
       raise NotImplementedError, "M√©todo 'acelerar' deve ser implementado na classe derivada."
     end

     def frear
       raise NotImplementedError, "M√©todo 'frear' deve ser implementado na classe derivada."
     end
   end

   class Carro < Veiculo
     def acelerar
       puts "Carro acelerando."
     end

     def frear
       puts "Carro freando."
     end
   end

   carro = Carro.new
   carro.acelerar
   carro.frear
   ```

   A classe abstrata `Veiculo` define m√©todos abstratos `acelerar` e `frear`, enquanto a classe `Carro` herda e implementa esses m√©todos essenciais, destacando a abstra√ß√£o de um ve√≠culo.

**3. Heran√ßa:**
   - A heran√ßa permite que uma classe herde caracter√≠sticas de outra classe, promovendo a reutiliza√ß√£o de c√≥digo.

   ```ruby
   class Animal
     def initialize(nome)
       @nome = nome
     end

     def falar
       raise NotImplementedError, "M√©todo 'falar' deve ser implementado na classe derivada."
     end
   end

   class Cachorro < Animal
     def falar
       puts "#{@nome} diz 'Au au!'"
     end
   end

   cachorro = Cachorro.new("Rex")
   cachorro.falar
   ```

   Neste exemplo, a classe `Cachorro` herda de `Animal`, aproveitando a estrutura e a funcionalidade comuns da classe pai e implementando o m√©todo `falar` de maneira espec√≠fica para cachorros.

**4. Polimorfismo:**
   - O polimorfismo permite que objetos de diferentes classes sejam tratados de forma uniforme, desde que implementem a mesma interface.

   ```ruby
   class Animal
     def falar
       raise NotImplementedError, "M√©todo 'falar' deve ser implementado na classe derivada."
     end
   end

   class Cachorro < Animal
     def falar
       puts "Cachorro diz 'Au au!'"
     end
   end

   class Gato < Animal
     def falar
       puts "Gato diz 'Miau! Miau!'"
     end
   end

   def fazer_barulho(animal)
     animal.falar
   end

   cachorro = Cachorro.new
   gato = Gato.new

   fazer_barulho(cachorro) # Chama o m√©todo falar de Cachorro
   fazer_barulho(gato)     # Chama o m√©todo falar de Gato
   ```

   O m√©todo `fazer_barulho` trata objetos de diferentes classes de forma uniforme, chamando o m√©todo `falar` correspondente, demonstrando o polimorfismo.

Estes s√£o exemplos de como os quatro pilares da POO (encapsulamento, abstra√ß√£o, heran√ßa e polimorfismo) podem ser implementados em Ruby para criar c√≥digo modular, reutiliz√°vel e flex√≠vel.

# üíñCARACTERISTICAS DA LINGUAGEM:
## ‚ù§POSITIVAS:
1. **Legibilidade e Simplicidade:** Ruby √© conhecida por sua sintaxe limpa e leg√≠vel. Ela foi projetada para ser f√°cil de ler e escrever, o que a torna uma √≥tima escolha para desenvolvedores de todos os n√≠veis de experi√™ncia.

2. **Produtividade:** Ruby enfatiza a produtividade do desenvolvedor. √â uma linguagem que permite que os programadores escrevam c√≥digo rapidamente, gra√ßas a sua sintaxe concisa e a uma grande biblioteca padr√£o.

3. **Orienta√ß√£o a Objetos Pura:** Ruby √© uma linguagem de programa√ß√£o orientada a objetos pura, o que significa que tudo em Ruby √© um objeto. Isso promove uma abordagem coesa e consistente para a programa√ß√£o.

4. **Flexibilidade:** Ruby √© altamente flex√≠vel e din√¢mica. Voc√™ pode adicionar ou modificar m√©todos e atributos em tempo de execu√ß√£o, o que permite uma grande flexibilidade ao criar e estender classes e objetos.

5. **Comunidade Ativa:** Ruby possui uma comunidade de desenvolvedores ativa e solid√°ria. Isso significa que voc√™ pode encontrar uma ampla variedade de bibliotecas, frameworks e recursos prontos para uso.

6. **Rails (Ruby on Rails):** Ruby √© a linguagem usada no Ruby on Rails, um dos frameworks web mais populares e poderosos. O Rails tornou Ruby ainda mais popular e √© amplamente usado para desenvolver aplicativos da web de alto desempenho.

7. **Multiplataforma:** Ruby √© compat√≠vel com v√°rias plataformas, incluindo Windows, macOS e Linux, tornando-a uma op√ß√£o vers√°til para o desenvolvimento de software.

8. **Teste e Depura√ß√£o:** Ruby oferece suporte nativo a testes e depura√ß√£o de c√≥digo, facilitando a cria√ß√£o de software confi√°vel e de alta qualidade.

9. **Compreens√£o Natural:** A linguagem foi projetada com a ideia de que o c√≥digo deve ser leg√≠vel como se fosse linguagem natural. Isso torna a colabora√ß√£o entre desenvolvedores mais eficaz e reduz a probabilidade de erros.

10. **Grande Ecossistema:** Ruby possui um ecossistema rico de bibliotecas e frameworks, o que simplifica o desenvolvimento de aplicativos em diversas √°reas, como desenvolvimento web, automa√ß√£o de tarefas, an√°lise de dados e muito mais.

## üñ§NEGATIVAS:
1. **Desempenho Relativo:** Comparado a algumas outras linguagens de programa√ß√£o, Ruby pode n√£o ser t√£o r√°pido em termos de desempenho. Isso pode ser um problema em aplicativos que exigem alta efici√™ncia computacional, como sistemas de tempo real ou c√°lculos intensivos.

2. **Consumo de Mem√≥ria:** Ruby pode ser relativamente intensivo em termos de consumo de mem√≥ria, o que pode ser um desafio em sistemas com recursos limitados.

3. **Gerenciamento de Mem√≥ria:** Ruby usa garbage collection para gerenciar a mem√≥ria, o que pode introduzir pequenos atrasos imprevis√≠veis na execu√ß√£o do programa. Isso pode n√£o ser adequado para aplicativos em tempo real ou de baixa lat√™ncia.

4. **Escalabilidade Vertical:** Ruby √†s vezes enfrenta desafios de escalabilidade vertical, o que significa que, para aumentar o desempenho de um aplicativo Ruby, pode ser necess√°rio aumentar significativamente os recursos de hardware, em vez de simplesmente adicionar mais servidores.

5. **Curva de Aprendizado:** Para desenvolvedores que est√£o acostumados com linguagens de programa√ß√£o mais tradicionais, a sintaxe e a filosofia de Ruby podem levar algum tempo para se acostumar.

6. **Documenta√ß√£o Irregular:** Embora Ruby tenha uma comunidade ativa, a qualidade e a consist√™ncia da documenta√ß√£o podem variar, o que pode dificultar a aprendizagem e a resolu√ß√£o de problemas para iniciantes.

7. **Mudan√ßas de Vers√£o:** Grandes atualiza√ß√µes da linguagem podem introduzir mudan√ßas significativas que quebram a compatibilidade com vers√µes anteriores. Isso pode requerer esfor√ßo para atualizar c√≥digo existente.

8. **Recursos Limitados em Dom√≠nios Espec√≠ficos:** Em alguns dom√≠nios espec√≠ficos, como desenvolvimento de jogos ou computa√ß√£o de alto desempenho, Ruby pode n√£o ser a melhor escolha devido a suas limita√ß√µes de desempenho.

9. **Menos Popular em Alguns Setores:** Embora Ruby seja popular no desenvolvimento web, pode n√£o ser a escolha predominante em alguns setores, como o desenvolvimento de aplicativos m√≥veis nativos.
